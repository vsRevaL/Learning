# 28. Feladatmegoldási stratégiák

`
Rekurzió. Oszd meg és uralkodj stratégia. Visszalépéses keresés, kiválogatás, maximum-kiválasztás. Mohó stratégia. Dinamikus programozás.
`

## Témák:

- Rekurzió / Recursion
- Dinamikus programozás / Dynamic programming
- Visszalépéses keresés / Backtracking
- Mohó stratégia / Greedy algorithms
- Oszd meg és uralkodj / Divide-and-conquer algorithm

- kiválogatás (???)
- maxmimum kiválasztás (???)

## Rekurzió

Mi a rekurzió? A rekurzizó nem más mint egy `önhivatkozás`, azaz egy függvény saját magát hívja meg.
Rekurzió kapcsán az egyik a legfontosabb a kilépési feltétel, mivel ha olyat nem adunk meg, a folyotonos hívások megtöltik a memóriának a `stack` részét, 
és a programunk elhal egy `Stackoverflow` erroral.

### Érvek a rekurzió mellett

- A rekurzió egy implicit vermet + ciklust használ, ezért azt nem kell leimplementálni a kódunkban,
- ezáltal csökken a komplex ciklusok és az ilyen kiegésztítő adatszerkezetek használata.
- A komplexitás könnyen csökkenhető `memorizálással`, mivel így a redundáns hívások megszüntethetőek, lásd később.: `Dynamic Programming`
- Nagyon jól működik a rekurzívan defininált struktúrákkal pl.: JSON objektumok, fák, gráfok; dolgok amik hagyják,
hogy egy időben egyszerre tudj foglalkozni az adattípus egy egységével.
- Gráfok, fák mélységi bejárásához szükségünk van egy verem adatszerkezetre, de mivel a rekurzió ezt implicit megcsinálja nekünk,
nem kell az implementálással foglalkozni, és szebb lesz a kódunk:

#### Egy gráf mélységi bejárás ciklussal + veremmel (no recursion):

```cs
void DepthFirstPrint(Dictionary<char, List<char>> graph, char source)
{
    Stack<char> stack = new Stack<char>();
    stack.Push(source);
    while (stack.Count > 0)
    {
        char current = stack.Pop();
        Console.Write(current + ", "); //adat kiírása a gráfban
        foreach (char neighbor in graph[current])
        {
            stack.Push(neighbor);
        }
    }
}
```

#### Rekurzívan:

```cs
void DepthFirstRecursive(Dictionary<char, List<char>> graph, char source)
{
    Console.Write(source + ", "); //adat kiírása a gráfban
    foreach (char neighbor in graph[source])
    {
        DepthFirstRecursive(graph, neighbor);
    }
}
```

### Érvek a rekurzió ellen

- Lassúság a CPU többletterhelése miatt, amit a sok method
hívás okoz a `call stack`-en. Metódusokat hívni lasabb, mint egy iterálni egy ciklusban,
ezért itt mérlegelnünk
- Ahogy nőnek a methodhísáok a memóriában, betelhet a memória `stack` része,
ami egy `StackOverFlow` kivétellel fogja zárni az előadást.
- Szükségtelenül komplexé teheti a kódot.


<br>
<br>
<br>